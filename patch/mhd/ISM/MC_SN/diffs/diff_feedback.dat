subroutine make_sn					      <
  use amr_commons					      <
  use hydro_commons					      <
  implicit none						      <
							      <
  integer:: ivar					      <
  integer:: ilevel, ind, ix, iy, iz, ngrid, iskip, idim	      <
  integer:: i, nx_loc, igrid, ncache			      <
  integer, dimension(1:nvector), save:: ind_grid, ind_cell    <
  real(dp):: dx						      <
  real(dp):: scale, dx_min, dx_loc, vol_loc		      <
  real(dp), dimension(1:3):: xbound, skip_loc		      <
  real(dp), dimension(1:twotondim, 1:3):: xc		      <
  logical, dimension(1:nvector), save:: ok		      <
							      <
  real(dp),dimension(1:ndim):: sn_cent			      <
  real(dp), dimension(1:nvector, 1:ndim), save:: xx	      <
  real(dp):: sn_r, sn_m, sn_e, sn_vol, sn_d, sn_ed, sn_rp, dx <
  real(dp):: rr, pi					      <
  logical:: sel = .false.				      <
  logical, save:: first = .true.			      <
  real(dp)::xseed					      <
							      <
  if(.not. hydro)return					      <
  if(ndim .ne. 3)return					      <
							      <
  if(verbose)write(*,*)'Entering make_sn'		      <
							      <
  pi = acos(-1.0)					      <
							      <
  ! Mesh spacing in that level				      <
  xbound(1:3) = (/ dble(nx), dble(ny), dble(nz) /)	      <
  nx_loc = icoarse_max - icoarse_min + 1		      <
  skip_loc = (/ 0.0d0, 0.0d0, 0.0d0 /)			      <
  skip_loc(1) = dble(icoarse_min)			      <
  skip_loc(2) = dble(jcoarse_min)			      <
  skip_loc(3) = dble(kcoarse_min)			      <
  scale = boxlen / dble(nx_loc)				      <
  dx_min = scale * 0.5d0**nlevelmax			      <
							      <
  if (first) then 					      <
     xseed=0.5						      <
     call random_number(xseed)				      <
     first=.false.					      <
  endif							      <
							      <
							      <
  if(sn_freq_mult .eq. 0.) then				      <
     sn_r = sn_radius(sn_i)				      <
     sn_m = sn_mass(sn_i)				      <
     sn_e = sn_energy(sn_i)				      <
     sn_rp = sn_part_radius(sn_i)			      <
     sn_cent(1) = sn_center(sn_i, 1)			      <
     sn_cent(2) = sn_center(sn_i, 2)			      <
     sn_cent(3) = sn_center(sn_i, 3)			      <
  else							      <
     sn_r = 3.*(0.5**levelmin)*scale			      <
     sn_m = sn_mass_ref					      <
     sn_e = sn_e_ref 					      <
     sn_rp = 0.						      <
     call random_number(xseed)				      <
     sn_cent(1)= xseed*boxlen				      <
     call random_number(xseed)				      <
     sn_cent(2)= xseed*boxlen				      <
     call random_number(xseed)				      <
     sn_cent(3)=(0.5 + (xseed-0.5) / 10. )*boxlen !assume mid <
  endif							      <
							      <
  if(sn_r /= 0.0) then					      <
    sn_vol = 4. / 3. * pi * sn_r**3			      <
    sn_d = sn_m / sn_vol				      <
    sn_ed = sn_e / sn_vol				      <
  end if						      <
							      <
  if(myid .eq. 1 .or. myid .eq. 2) then			      <
   write(*,*) 'x_sn, y_sn, z_sn, ',sn_cent(1),sn_cent(2),sn_c <
  endif							      <
							      <
  ! Loop over levels					      <
  do ilevel = levelmin, nlevelmax			      <
    ! Computing local volume (important for averaging hydro q <
    dx = 0.5d0**ilevel					      <
    dx_loc = dx * scale					      <
    vol_loc = dx_loc**ndim				      <
    !if(.not. sel) then					      <
      ! dx_sel will contain the size of the biggest leaf cell <
      !dx_sel = dx_loc					      <
      !sn_vol = vol_loc					      <
    !end if						      <
							      <
    ! Cell center position relative to grid center position   <
    do ind=1,twotondim					      <
      iz = (ind - 1) / 4				      <
      iy = (ind - 1 - 4 * iz) / 2			      <
      ix = (ind - 1 - 2 * iy - 4 * iz)			      <
      xc(ind,1) = (dble(ix) - 0.5d0) * dx		      <
      xc(ind,2) = (dble(iy) - 0.5d0) * dx		      <
      xc(ind,3) = (dble(iz) - 0.5d0) * dx		      <
    end do						      <
							      <
    ! Loop over grids					      <
    ncache=active(ilevel)%ngrid				      <
    do igrid = 1, ncache, nvector			      <
      ngrid = min(nvector, ncache - igrid + 1)		      <
      do i = 1, ngrid					      <
        ind_grid(i) = active(ilevel)%igrid(igrid + i - 1)     <
      end do						      <
							      <
      ! Loop over cells					      <
      do ind = 1, twotondim				      <
        ! Gather cell indices				      <
        iskip = ncoarse + (ind - 1) * ngridmax		      <
        do i = 1, ngrid					      <
          ind_cell(i) = iskip + ind_grid(i)		      <
        end do						      <
							      <
        ! Gather cell center positions			      <
        do i = 1, ngrid					      <
          xx(i, :) = xg(ind_grid(i), :) + xc(ind, :)	      <
        end do						      <
        ! Rescale position from coarse grid units to code uni <
        do i = 1, ngrid					      <
           xx(i, :) = (xx(i, :) - skip_loc(:)) * scale	      <
        end do						      <
							      <
        ! Flag leaf cells				      <
        do i = 1, ngrid					      <
          ok(i) = (son(ind_cell(i)) == 0)		      <
        end do						      <
							      <
        do i = 1, ngrid					      <
          if(ok(i)) then				      <
            if(sn_r == 0.0) then			      <
              sn_d = sn_m / vol_loc ! XXX		      <
              sn_ed = sn_e / vol_loc ! XXX		      <
              rr = 1.0					      <
              do idim = 1, 3				      <
                !rr = rr * max(1.0 - abs(xx(i, idim) - sn_cen <
                rr = rr * max(1.0 - abs(xx(i, idim) - sn_cent <
              end do					      <
              !if(rr > 0.0) then			      <
                !if(.not. sel) then			      <
                  !! We found a leaf cell near the supernova  <
                  !sel = .true.				      <
                  !sn_d = sn_m / sn_vol			      <
                  !sn_ed = sn_e / sn_vol		      <
                !end if					      <
                uold(ind_cell(i), 1) = uold(ind_cell(i), 1) + <
                uold(ind_cell(i), 5) = uold(ind_cell(i), 5) + <
              !end if					      <
            else					      <
              rr = sum(((xx(i, :) - sn_cent(:)) / sn_r)**2)   <
							      <
              if(rr < 1.) then				      <
                uold(ind_cell(i), 1) = uold(ind_cell(i), 1) + <
                uold(ind_cell(i), 5) = uold(ind_cell(i), 5) + <
              endif					      <
            endif					      <
          endif						      <
        end do						      <
      end do						      <
      ! End loop over cells				      <
    end do						      <
    ! End loop over grids				      <
  end do						      <
  ! End loop over levels				      <
							      <
  ! Update hydro quantities for split cells		      <
  do ilevel = nlevelmax, levelmin, -1			      <
    call upload_fine(ilevel)				      <
    do ivar = 1, nvar					      <
      call make_virtual_fine_dp(uold(1, ivar), ilevel)	      <
    enddo						      <
  enddo							      <
end subroutine make_sn					      <
!############################################################	!############################################################
!############################################################	!############################################################
!############################################################	!############################################################
!############################################################	!############################################################
subroutine thermal_feedback(ilevel,icount)			subroutine thermal_feedback(ilevel,icount)
  use pm_commons						  use pm_commons
  use amr_commons						  use amr_commons
  implicit none							  implicit none
  integer::ilevel,icount					  integer::ilevel,icount
  !----------------------------------------------------------	  !----------------------------------------------------------
  ! This routine computes the thermal energy, the kinetic ene	  ! This routine computes the thermal energy, the kinetic ene
  ! the metal mass dumped in the gas by stars (SNII, SNIa, wi	  ! the metal mass dumped in the gas by stars (SNII, SNIa, wi
  ! This routine is called every fine time step.		  ! This routine is called every fine time step.
  !----------------------------------------------------------	  !----------------------------------------------------------
  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v	  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v
  real(dp)::t0,scale,dx_min,vsn,rdebris,ethermal		  real(dp)::t0,scale,dx_min,vsn,rdebris,ethermal
  integer::igrid,jgrid,ipart,jpart,next_part			  integer::igrid,jgrid,ipart,jpart,next_part
  integer::i,ig,ip,npart1,npart2,icpu,nx_loc			  integer::i,ig,ip,npart1,npart2,icpu,nx_loc
  real(dp),dimension(1:3)::skip_loc				  real(dp),dimension(1:3)::skip_loc
  integer,dimension(1:nvector),save::ind_grid,ind_part,ind_gr	  integer,dimension(1:nvector),save::ind_grid,ind_part,ind_gr

  if(numbtot(1,ilevel)==0)return				  if(numbtot(1,ilevel)==0)return
  if(verbose)write(*,111)ilevel					  if(verbose)write(*,111)ilevel
  if(icount==2)return						  if(icount==2)return

  ! Gather star particles only.					  ! Gather star particles only.

#if NDIM==3							#if NDIM==3
  ! Loop over cpus						  ! Loop over cpus
  do icpu=1,ncpu						  do icpu=1,ncpu
     igrid=headl(icpu,ilevel)					     igrid=headl(icpu,ilevel)
     ig=0							     ig=0
     ip=0							     ip=0
     ! Loop over grids						     ! Loop over grids
     do jgrid=1,numbl(icpu,ilevel)				     do jgrid=1,numbl(icpu,ilevel)
        npart1=numbp(igrid)  ! Number of particles in the gri	        npart1=numbp(igrid)  ! Number of particles in the gri
        npart2=0						        npart2=0
        							        
        ! Count star particles					        ! Count star particles
        if(npart1>0)then					        if(npart1>0)then
           ipart=headp(igrid)					           ipart=headp(igrid)
           ! Loop over particles				           ! Loop over particles
           do jpart=1,npart1					           do jpart=1,npart1
              ! Save next particle   <--- Very important !!!	              ! Save next particle   <--- Very important !!!
              next_part=nextp(ipart)				              next_part=nextp(ipart)
              if(idp(ipart).gt.0.and.tp(ipart).ne.0)then	              if(idp(ipart).gt.0.and.tp(ipart).ne.0)then
                 npart2=npart2+1				                 npart2=npart2+1
              endif						              endif
              ipart=next_part  ! Go to next particle		              ipart=next_part  ! Go to next particle
           end do						           end do
        endif							        endif
        							        
        ! Gather star particles					        ! Gather star particles
        if(npart2>0)then        				        if(npart2>0)then        
           ig=ig+1						           ig=ig+1
           ind_grid(ig)=igrid					           ind_grid(ig)=igrid
           ipart=headp(igrid)					           ipart=headp(igrid)
           ! Loop over particles				           ! Loop over particles
           do jpart=1,npart1					           do jpart=1,npart1
              ! Save next particle   <--- Very important !!!	              ! Save next particle   <--- Very important !!!
              next_part=nextp(ipart)				              next_part=nextp(ipart)
              ! Select only star particles			              ! Select only star particles
              if(idp(ipart).gt.0.and.tp(ipart).ne.0)then	              if(idp(ipart).gt.0.and.tp(ipart).ne.0)then
                 if(ig==0)then					                 if(ig==0)then
                    ig=1					                    ig=1
                    ind_grid(ig)=igrid				                    ind_grid(ig)=igrid
                 end if						                 end if
                 ip=ip+1					                 ip=ip+1
                 ind_part(ip)=ipart				                 ind_part(ip)=ipart
                 ind_grid_part(ip)=ig   			                 ind_grid_part(ip)=ig   
              endif						              endif
              if(ip==nvector)then				              if(ip==nvector)then
                 call feedbk(ind_grid,ind_part,ind_grid_part,	                 call feedbk(ind_grid,ind_part,ind_grid_part,
                 ip=0						                 ip=0
                 ig=0						                 ig=0
              end if						              end if
              ipart=next_part  ! Go to next particle		              ipart=next_part  ! Go to next particle
           end do						           end do
           ! End loop over particles				           ! End loop over particles
        end if							        end if
        igrid=next(igrid)   ! Go to next grid			        igrid=next(igrid)   ! Go to next grid
     end do							     end do
     ! End loop over grids					     ! End loop over grids
     if(ip>0)call feedbk(ind_grid,ind_part,ind_grid_part,ig,i	     if(ip>0)call feedbk(ind_grid,ind_part,ind_grid_part,ig,i
  end do 							  end do 
  ! End loop over cpus						  ! End loop over cpus

#endif								#endif

111 format('   Entering thermal_feedback for level ',I2)	111 format('   Entering thermal_feedback for level ',I2)

end subroutine thermal_feedback					end subroutine thermal_feedback
!############################################################	!############################################################
!############################################################	!############################################################
!############################################################	!############################################################
!############################################################	!############################################################
subroutine feedbk(ind_grid,ind_part,ind_grid_part,ng,np,ileve	subroutine feedbk(ind_grid,ind_part,ind_grid_part,ng,np,ileve
  use amr_commons						  use amr_commons
  use pm_commons						  use pm_commons
  use hydro_commons						  use hydro_commons
  use random							  use random
  implicit none							  implicit none
  integer::ng,np,ilevel						  integer::ng,np,ilevel
  integer,dimension(1:nvector)::ind_grid			  integer,dimension(1:nvector)::ind_grid
  integer,dimension(1:nvector)::ind_grid_part,ind_part		  integer,dimension(1:nvector)::ind_grid_part,ind_part
  !----------------------------------------------------------	  !----------------------------------------------------------
  ! This routine is called by subroutine feedback. Each debri	  ! This routine is called by subroutine feedback. Each debri
  ! dumps mass, momentum and energy in the nearest grid cell 	  ! dumps mass, momentum and energy in the nearest grid cell 
  ! uold.							  ! uold.
  !----------------------------------------------------------	  !----------------------------------------------------------
  integer::i,j,idim,nx_loc					  integer::i,j,idim,nx_loc
  real(kind=8)::RandNum						  real(kind=8)::RandNum
  real(dp)::SN_BOOST,mstar,dx_min,vol_min			  real(dp)::SN_BOOST,mstar,dx_min,vol_min
  real(dp)::xxx,mmm,t0,ESN,mejecta,zloss			  real(dp)::xxx,mmm,t0,ESN,mejecta,zloss
  real(dp)::dx,dx_loc,scale,vol_loc,birth_time		      |	  real(dp)::ERAD,RAD_BOOST,tauIR,eta_sig
							      >	  real(dp)::sigma_d,delta_x,tau_factor,rad_factor
							      >	  real(dp)::dx,dx_loc,scale,vol_loc,birth_time,current_time
  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v	  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v
  logical::error						  logical::error
  ! Grid based arrays						  ! Grid based arrays
  real(dp),dimension(1:nvector,1:ndim),save::x0			  real(dp),dimension(1:nvector,1:ndim),save::x0
  integer ,dimension(1:nvector),save::ind_cell			  integer ,dimension(1:nvector),save::ind_cell
  integer ,dimension(1:nvector,1:threetondim),save::nbors_fat	  integer ,dimension(1:nvector,1:threetondim),save::nbors_fat
  integer ,dimension(1:nvector,1:twotondim),save::nbors_fathe	  integer ,dimension(1:nvector,1:twotondim),save::nbors_fathe
  ! Particle based arrays					  ! Particle based arrays
  integer,dimension(1:nvector),save::igrid_son,ind_son		  integer,dimension(1:nvector),save::igrid_son,ind_son
  integer,dimension(1:nvector),save::list1			  integer,dimension(1:nvector),save::list1
  logical,dimension(1:nvector),save::ok				  logical,dimension(1:nvector),save::ok
  real(dp),dimension(1:nvector),save::mloss,mzloss,ethermal,e	  real(dp),dimension(1:nvector),save::mloss,mzloss,ethermal,e
  real(dp),dimension(1:nvector,1:ndim),save::x			  real(dp),dimension(1:nvector,1:ndim),save::x
  integer ,dimension(1:nvector,1:ndim),save::id,igd,icd		  integer ,dimension(1:nvector,1:ndim),save::id,igd,icd
  integer ,dimension(1:nvector),save::igrid,icell,indp,kg	  integer ,dimension(1:nvector),save::igrid,icell,indp,kg
  real(dp),dimension(1:3)::skip_loc				  real(dp),dimension(1:3)::skip_loc

  ! Conversion factor from user units to cgs units		  ! Conversion factor from user units to cgs units
  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T	  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T

  ! Mesh spacing in that level					  ! Mesh spacing in that level
  dx=0.5D0**ilevel						  dx=0.5D0**ilevel
  nx_loc=(icoarse_max-icoarse_min+1)				  nx_loc=(icoarse_max-icoarse_min+1)
  skip_loc=(/0.0d0,0.0d0,0.0d0/)				  skip_loc=(/0.0d0,0.0d0,0.0d0/)
  if(ndim>0)skip_loc(1)=dble(icoarse_min)			  if(ndim>0)skip_loc(1)=dble(icoarse_min)
  if(ndim>1)skip_loc(2)=dble(jcoarse_min)			  if(ndim>1)skip_loc(2)=dble(jcoarse_min)
  if(ndim>2)skip_loc(3)=dble(kcoarse_min)			  if(ndim>2)skip_loc(3)=dble(kcoarse_min)
  scale=boxlen/dble(nx_loc)					  scale=boxlen/dble(nx_loc)
  dx_loc=dx*scale						  dx_loc=dx*scale
  vol_loc=dx_loc**ndim						  vol_loc=dx_loc**ndim
  dx_min=(0.5D0**nlevelmax)*scale				  dx_min=(0.5D0**nlevelmax)*scale
  vol_min=dx_min**ndim						  vol_min=dx_min**ndim

  ! Minimum star particle mass					  ! Minimum star particle mass
  if(m_star < 0d0)then						  if(m_star < 0d0)then
     mstar=n_star/(scale_nH*aexp**3)*vol_min			     mstar=n_star/(scale_nH*aexp**3)*vol_min
  else								  else
     mstar=m_star*mass_sph					     mstar=m_star*mass_sph
  endif								  endif

  ! Compute stochastic boost to account for target GMC mass	  ! Compute stochastic boost to account for target GMC mass
  SN_BOOST=MAX(mass_gmc*2d33/(scale_d*scale_l**3)/mstar,1d0)	  SN_BOOST=MAX(mass_gmc*2d33/(scale_d*scale_l**3)/mstar,1d0)

  ! Massive star lifetime from Myr to code units		  ! Massive star lifetime from Myr to code units
  t0=10.*1d6*(365.*24.*3600.)/scale_t			      |	  if(use_proper_time)then
							      >	     t0=10.*1d6*(365.*24.*3600.)/(scale_t/aexp**2)
							      >	     current_time=texp
							      >	  else
							      >	     t0=10.*1d6*(365.*24.*3600.)/scale_t
							      >	     current_time=t
							      >	  endif

  ! Type II supernova specific energy from cgs to code units	  ! Type II supernova specific energy from cgs to code units
  ESN=1d51/(10.*2d33)/scale_v**2				  ESN=1d51/(10.*2d33)/scale_v**2

							      >	  ! Life time radiation specific energy from cgs to code unit
							      >	  ERAD=1d53/(10.*2d33)/scale_v**2
							      >
#if NDIM==3							#if NDIM==3
  ! Lower left corner of 3x3x3 grid-cube			  ! Lower left corner of 3x3x3 grid-cube
  do idim=1,ndim						  do idim=1,ndim
     do i=1,ng							     do i=1,ng
        x0(i,idim)=xg(ind_grid(i),idim)-3.0D0*dx		        x0(i,idim)=xg(ind_grid(i),idim)-3.0D0*dx
     end do							     end do
  end do							  end do

  ! Gather 27 neighboring father cells (should be present any	  ! Gather 27 neighboring father cells (should be present any
  do i=1,ng							  do i=1,ng
     ind_cell(i)=father(ind_grid(i))				     ind_cell(i)=father(ind_grid(i))
  end do							  end do
  call get3cubefather(ind_cell,nbors_father_cells,nbors_fathe	  call get3cubefather(ind_cell,nbors_father_cells,nbors_fathe

  ! Rescale position at level ilevel				  ! Rescale position at level ilevel
  do idim=1,ndim						  do idim=1,ndim
     do j=1,np							     do j=1,np
        x(j,idim)=xp(ind_part(j),idim)/scale+skip_loc(idim)	        x(j,idim)=xp(ind_part(j),idim)/scale+skip_loc(idim)
     end do							     end do
  end do							  end do
  do idim=1,ndim						  do idim=1,ndim
     do j=1,np							     do j=1,np
        x(j,idim)=x(j,idim)-x0(ind_grid_part(j),idim)		        x(j,idim)=x(j,idim)-x0(ind_grid_part(j),idim)
     end do							     end do
  end do							  end do
  do idim=1,ndim						  do idim=1,ndim
     do j=1,np							     do j=1,np
        x(j,idim)=x(j,idim)/dx					        x(j,idim)=x(j,idim)/dx
     end do							     end do
  end do							  end do

  ! Check for illegal moves					  ! Check for illegal moves
  error=.false.							  error=.false.
  do idim=1,ndim						  do idim=1,ndim
     do j=1,np							     do j=1,np
        if(x(j,idim)<=2.0D0.or.x(j,idim)>=4.0D0)error=.true.	        if(x(j,idim)<=2.0D0.or.x(j,idim)>=4.0D0)error=.true.
     end do							     end do
  end do							  end do
  if(error)then							  if(error)then
     write(*,*)'problem in sn2'					     write(*,*)'problem in sn2'
     write(*,*)ilevel,ng,np					     write(*,*)ilevel,ng,np
  end if							  end if

  ! NGP at level ilevel						  ! NGP at level ilevel
  do idim=1,ndim						  do idim=1,ndim
     do j=1,np							     do j=1,np
        id(j,idim)=x(j,idim)					        id(j,idim)=x(j,idim)
     end do							     end do
  end do							  end do

   ! Compute parent grids					   ! Compute parent grids
  do idim=1,ndim						  do idim=1,ndim
     do j=1,np							     do j=1,np
        igd(j,idim)=id(j,idim)/2				        igd(j,idim)=id(j,idim)/2
     end do							     end do
  end do							  end do
  do j=1,np							  do j=1,np
     kg(j)=1+igd(j,1)+3*igd(j,2)+9*igd(j,3)			     kg(j)=1+igd(j,1)+3*igd(j,2)+9*igd(j,3)
  end do							  end do
  do j=1,np							  do j=1,np
     igrid(j)=son(nbors_father_cells(ind_grid_part(j),kg(j)))	     igrid(j)=son(nbors_father_cells(ind_grid_part(j),kg(j)))
  end do							  end do

  ! Check if particles are entirely in level ilevel		  ! Check if particles are entirely in level ilevel
  ok(1:np)=.true.						  ok(1:np)=.true.
  do j=1,np							  do j=1,np
     ok(j)=ok(j).and.igrid(j)>0					     ok(j)=ok(j).and.igrid(j)>0
  end do							  end do

  ! Compute parent cell position				  ! Compute parent cell position
  do idim=1,ndim						  do idim=1,ndim
     do j=1,np							     do j=1,np
        if(ok(j))then						        if(ok(j))then
           icd(j,idim)=id(j,idim)-2*igd(j,idim)			           icd(j,idim)=id(j,idim)-2*igd(j,idim)
        end if							        end if
     end do							     end do
  end do							  end do
  do j=1,np							  do j=1,np
     if(ok(j))then						     if(ok(j))then
        icell(j)=1+icd(j,1)+2*icd(j,2)+4*icd(j,3)		        icell(j)=1+icd(j,1)+2*icd(j,2)+4*icd(j,3)
     end if							     end if
  end do							  end do

  ! Compute parent cell adresses				  ! Compute parent cell adresses
  do j=1,np							  do j=1,np
     if(ok(j))then						     if(ok(j))then
        indp(j)=ncoarse+(icell(j)-1)*ngridmax+igrid(j)		        indp(j)=ncoarse+(icell(j)-1)*ngridmax+igrid(j)
     end if							     end if
  end do							  end do

  ! Compute individual time steps				  ! Compute individual time steps
  ! WARNING: the time step is always the coarser level time s	  ! WARNING: the time step is always the coarser level time s
  ! since we do not have feedback for icount=2			  ! since we do not have feedback for icount=2
  if(ilevel==levelmin)then					  if(ilevel==levelmin)then
     do j=1,np							     do j=1,np
        if(ok(j))then						        if(ok(j))then
           dteff(j)=dtold(levelp(ind_part(j)))			           dteff(j)=dtold(levelp(ind_part(j)))
        end if							        end if
     end do							     end do
  else								  else
     do j=1,np							     do j=1,np
        if(ok(j))then						        if(ok(j))then
           dteff(j)=dtold(levelp(ind_part(j))-1)		           dteff(j)=dtold(levelp(ind_part(j))-1)
        end if							        end if
     end do							     end do
  endif								  endif
							      >	  if(use_proper_time)then
							      >	     do j=1,np
							      >	        if(ok(j))then
							      >	           dteff(j)=dteff(j)*aexp**2
							      >	        end if
							      >	     end do
							      >	  endif

  ! Reset ejected mass, metallicity, thermal energy		  ! Reset ejected mass, metallicity, thermal energy
  do j=1,np							  do j=1,np
     if(ok(j))then						     if(ok(j))then
        mloss(j)=0d0						        mloss(j)=0d0
        mzloss(j)=0d0						        mzloss(j)=0d0
        ethermal(j)=0d0						        ethermal(j)=0d0
     endif							     endif
  end do							  end do

  ! Compute stellar mass loss and thermal feedback due to sup	  ! Compute stellar mass loss and thermal feedback due to sup
  if(f_w==0)then						  if(f_w==0)then
     do j=1,np							     do j=1,np
        if(ok(j))then						        if(ok(j))then
           birth_time=tp(ind_part(j))				           birth_time=tp(ind_part(j))
           ! Make sure that we don't count feedback twice	           ! Make sure that we don't count feedback twice
           if(birth_time.lt.(t-t0).and.birth_time.ge.(t-t0-dt |	           if(birth_time.lt.(current_time-t0).and.birth_time.
              ! Stellar mass loss				              ! Stellar mass loss
              mejecta=eta_sn*mp(ind_part(j))			              mejecta=eta_sn*mp(ind_part(j))
              mloss(j)=mloss(j)+mejecta/vol_loc			              mloss(j)=mloss(j)+mejecta/vol_loc
              ! Thermal energy					              ! Thermal energy
              ethermal(j)=ethermal(j)+mejecta*ESN/vol_loc	              ethermal(j)=ethermal(j)+mejecta*ESN/vol_loc
              ! Metallicity					              ! Metallicity
              if(metal)then					              if(metal)then
                 zloss=yield+(1d0-yield)*zp(ind_part(j))	                 zloss=yield+(1d0-yield)*zp(ind_part(j))
                 mzloss(j)=mzloss(j)+mejecta*zloss/vol_loc	                 mzloss(j)=mzloss(j)+mejecta*zloss/vol_loc
              endif						              endif
              ! Reduce star particle mass			              ! Reduce star particle mass
              mp(ind_part(j))=mp(ind_part(j))-mejecta		              mp(ind_part(j))=mp(ind_part(j))-mejecta
              ! Boost SNII energy and depopulate accordingly	              ! Boost SNII energy and depopulate accordingly
              if(SN_BOOST>1d0)then				              if(SN_BOOST>1d0)then
                 call ranf(localseed,RandNum)			                 call ranf(localseed,RandNum)
                 if(RandNum<1d0/SN_BOOST)then			                 if(RandNum<1d0/SN_BOOST)then
                    mloss(j)=SN_BOOST*mloss(j)			                    mloss(j)=SN_BOOST*mloss(j)
                    mzloss(j)=SN_BOOST*mzloss(j)		                    mzloss(j)=SN_BOOST*mzloss(j)
                    ethermal(j)=SN_BOOST*ethermal(j)		                    ethermal(j)=SN_BOOST*ethermal(j)
                 else						                 else
                    mloss(j)=0d0				                    mloss(j)=0d0
                    mzloss(j)=0d0				                    mzloss(j)=0d0
                    ethermal(j)=0d0				                    ethermal(j)=0d0
                 endif						                 endif
              endif						              endif
           endif						           endif
        end if							        end if
     end do							     end do
  endif								  endif

  ! Update hydro variables due to feedback			  ! Update hydro variables due to feedback
							      >
							      >	  ! For IR radiation trapping,
							      >	  ! we use the cell resolution to estimate the column density
							      >	  delta_x=200*3d18
							      >	  if(metal)then
							      >	     tau_factor=kappa_IR*delta_x*scale_d/0.02
							      >	  else
							      >	     tau_factor=kappa_IR*delta_x*scale_d*z_ave
							      >	  endif
							      >	  rad_factor=ERAD/ESN
  do j=1,np							  do j=1,np
     if(ok(j))then						     if(ok(j))then
							      >
							      >	        ! Infrared photon trapping boost
							      >	        if(metal)then
							      >	           tauIR=tau_factor*max(uold(indp(j),imetal),smallr)
							      >	        else
							      >	           tauIR=tau_factor*max(uold(indp(j),1),smallr)
							      >	        endif
							      >	        RAD_BOOST=rad_factor*(1d0-exp(-tauIR))
							      >	        
        ! Specific kinetic energy of the star			        ! Specific kinetic energy of the star
        ekinetic(j)=0.5*(vp(ind_part(j),1)**2 &			        ekinetic(j)=0.5*(vp(ind_part(j),1)**2 &
             &          +vp(ind_part(j),2)**2 &			             &          +vp(ind_part(j),2)**2 &
             &          +vp(ind_part(j),3)**2)			             &          +vp(ind_part(j),3)**2)
        ! Update hydro variable in NGP cell			        ! Update hydro variable in NGP cell
        uold(indp(j),1)=uold(indp(j),1)+mloss(j)		        uold(indp(j),1)=uold(indp(j),1)+mloss(j)
        uold(indp(j),2)=uold(indp(j),2)+mloss(j)*vp(ind_part(	        uold(indp(j),2)=uold(indp(j),2)+mloss(j)*vp(ind_part(
        uold(indp(j),3)=uold(indp(j),3)+mloss(j)*vp(ind_part(	        uold(indp(j),3)=uold(indp(j),3)+mloss(j)*vp(ind_part(
        uold(indp(j),4)=uold(indp(j),4)+mloss(j)*vp(ind_part(	        uold(indp(j),4)=uold(indp(j),4)+mloss(j)*vp(ind_part(
        uold(indp(j),5)=uold(indp(j),5)+mloss(j)*ekinetic(j)+ |	        uold(indp(j),5)=uold(indp(j),5)+mloss(j)*ekinetic(j)+
							      >	             & ethermal(j)*(1d0+RAD_BOOST)
        							        
     endif							     endif
  end do							  end do

  ! Add metals							  ! Add metals
  if(metal)then							  if(metal)then
     do j=1,np							     do j=1,np
        if(ok(j))then						        if(ok(j))then
           uold(indp(j),imetal)=uold(indp(j),imetal)+mzloss(j	           uold(indp(j),imetal)=uold(indp(j),imetal)+mzloss(j
        endif							        endif
     end do							     end do
  endif								  endif

  ! Add delayed cooling switch variable				  ! Add delayed cooling switch variable
  if(delayed_cooling)then					  if(delayed_cooling)then
     do j=1,np							     do j=1,np
        if(ok(j))then						        if(ok(j))then
           uold(indp(j),idelay)=uold(indp(j),idelay)+mloss(j)	           uold(indp(j),idelay)=uold(indp(j),idelay)+mloss(j)
        endif							        endif
     end do							     end do
  endif								  endif

#endif								#endif
  								  
end subroutine feedbk						end subroutine feedbk
!############################################################	!############################################################
!############################################################	!############################################################
!############################################################	!############################################################
!############################################################	!############################################################
subroutine kinetic_feedback					subroutine kinetic_feedback
  use amr_commons						  use amr_commons
  use pm_commons						  use pm_commons
  use hydro_commons						  use hydro_commons
  use cooling_module, ONLY: XH=>X, rhoc, mH 			  use cooling_module, ONLY: XH=>X, rhoc, mH 
  implicit none							  implicit none
#ifndef WITHOUTMPI						#ifndef WITHOUTMPI
  include 'mpif.h'						  include 'mpif.h'
  integer::nSN_tot_all						  integer::nSN_tot_all
  integer,dimension(1:ncpu)::nSN_icpu_all			  integer,dimension(1:ncpu)::nSN_icpu_all
  real(dp),dimension(:),allocatable::mSN_all,sSN_all,ZSN_all	  real(dp),dimension(:),allocatable::mSN_all,sSN_all,ZSN_all
  real(dp),dimension(:,:),allocatable::xSN_all,vSN_all		  real(dp),dimension(:,:),allocatable::xSN_all,vSN_all
#endif								#endif
  !----------------------------------------------------------	  !----------------------------------------------------------
  ! This subroutine compute the kinetic feedback due to SNII 	  ! This subroutine compute the kinetic feedback due to SNII 
  ! imolement this using exploding GMC particles. 		  ! imolement this using exploding GMC particles. 
  ! This routine is called only at coarse time step.		  ! This routine is called only at coarse time step.
  ! Yohan Dubois						  ! Yohan Dubois
  !----------------------------------------------------------	  !----------------------------------------------------------
  ! local constants						  ! local constants
  integer::ip,icpu,igrid,jgrid,npart1,npart2,ipart,jpart,next	  integer::ip,icpu,igrid,jgrid,npart1,npart2,ipart,jpart,next
  integer::nSN,nSN_loc,nSN_tot,info,iSN,ilevel,ivar		  integer::nSN,nSN_loc,nSN_tot,info,iSN,ilevel,ivar
  integer,dimension(1:ncpu)::nSN_icpu				  integer,dimension(1:ncpu)::nSN_icpu
  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v	  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v
							      >	  real(dp)::current_time
  real(dp)::scale,dx_min,vol_min,nISM,nCOM,d0,mstar		  real(dp)::scale,dx_min,vol_min,nISM,nCOM,d0,mstar
  integer::nx_loc						  integer::nx_loc
  integer,dimension(:),allocatable::ind_part,ind_grid		  integer,dimension(:),allocatable::ind_part,ind_grid
  logical,dimension(:),allocatable::ok_free			  logical,dimension(:),allocatable::ok_free
  integer ,dimension(:),allocatable::indSN			  integer ,dimension(:),allocatable::indSN
  real(dp),dimension(:),allocatable::mSN,sSN,ZSN,m_gas,vol_ga	  real(dp),dimension(:),allocatable::mSN,sSN,ZSN,m_gas,vol_ga
  real(dp),dimension(:,:),allocatable::xSN,vSN,u_gas,dq		  real(dp),dimension(:,:),allocatable::xSN,vSN,u_gas,dq

  if(.not. hydro)return						  if(.not. hydro)return
  if(ndim.ne.3)return						  if(ndim.ne.3)return

  if(verbose)write(*,*)'Entering make_sn'			  if(verbose)write(*,*)'Entering make_sn'
  								  
  ! Conversion factor from user units to cgs units		  ! Conversion factor from user units to cgs units
  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T	  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T

  ! Mesh spacing in that level					  ! Mesh spacing in that level
  nx_loc=(icoarse_max-icoarse_min+1)				  nx_loc=(icoarse_max-icoarse_min+1)
  scale=boxlen/dble(nx_loc)					  scale=boxlen/dble(nx_loc)
  dx_min=(0.5D0**nlevelmax)*scale				  dx_min=(0.5D0**nlevelmax)*scale
  vol_min=dx_min**ndim						  vol_min=dx_min**ndim

  ! Initial star particle mass					  ! Initial star particle mass
  mstar=n_star/(scale_nH*aexp**3)*vol_min			  mstar=n_star/(scale_nH*aexp**3)*vol_min

  ! Lifetime of Giant Molecular Clouds from Myr to code units	  ! Lifetime of Giant Molecular Clouds from Myr to code units
  t0=10.*(1d6*365.*24.*3600.)/scale_t			      |	  ! Massive star lifetime from Myr to code units
							      >	  if(use_proper_time)then
							      >	     t0=10.*1d6*(365.*24.*3600.)/(scale_t/aexp**2)
							      >	     current_time=texp
							      >	  else
							      >	     t0=10.*1d6*(365.*24.*3600.)/scale_t
							      >	     current_time=t
							      >	  endif

  !------------------------------------------------------	  !------------------------------------------------------
  ! Gather GMC particles eligible for disruption		  ! Gather GMC particles eligible for disruption
  !------------------------------------------------------	  !------------------------------------------------------
  nSN_loc=0							  nSN_loc=0
  ! Loop over levels						  ! Loop over levels
  do icpu=1,ncpu						  do icpu=1,ncpu
  ! Loop over cpus						  ! Loop over cpus
     igrid=headl(icpu,levelmin)					     igrid=headl(icpu,levelmin)
     ! Loop over grids						     ! Loop over grids
     do jgrid=1,numbl(icpu,levelmin)				     do jgrid=1,numbl(icpu,levelmin)
        npart1=numbp(igrid)  ! Number of particles in the gri	        npart1=numbp(igrid)  ! Number of particles in the gri
        npart2=0						        npart2=0
        ! Count old enough GMC particles			        ! Count old enough GMC particles
        if(npart1>0)then					        if(npart1>0)then
           ipart=headp(igrid)					           ipart=headp(igrid)
           ! Loop over particles				           ! Loop over particles
           do jpart=1,npart1					           do jpart=1,npart1
              ! Save next particle   <--- Very important !!!	              ! Save next particle   <--- Very important !!!
              next_part=nextp(ipart)				              next_part=nextp(ipart)
              if(idp(ipart).le.0.and. tp(ipart).lt.(t-t0))the |	              if(idp(ipart).le.0.and. tp(ipart).lt.(current_t
                 npart2=npart2+1				                 npart2=npart2+1
              endif						              endif
              ipart=next_part  ! Go to next particle		              ipart=next_part  ! Go to next particle
            end do						            end do
        endif							        endif
        nSN_loc=nSN_loc+npart2   ! Add SNe to the total		        nSN_loc=nSN_loc+npart2   ! Add SNe to the total
        igrid=next(igrid)   ! Go to next grid			        igrid=next(igrid)   ! Go to next grid
     end do							     end do
  end do							  end do
  ! End loop over levels					  ! End loop over levels
  nSN_icpu=0							  nSN_icpu=0
  nSN_icpu(myid)=nSN_loc					  nSN_icpu(myid)=nSN_loc
#ifndef WITHOUTMPI						#ifndef WITHOUTMPI
  ! Give an array of number of SN on each cpu available to al	  ! Give an array of number of SN on each cpu available to al
  call MPI_ALLREDUCE(nSN_icpu,nSN_icpu_all,ncpu,MPI_INTEGER,M	  call MPI_ALLREDUCE(nSN_icpu,nSN_icpu_all,ncpu,MPI_INTEGER,M
  nSN_icpu=nSN_icpu_all						  nSN_icpu=nSN_icpu_all
#endif								#endif

  nSN_tot=sum(nSN_icpu(1:ncpu))					  nSN_tot=sum(nSN_icpu(1:ncpu))

  if (nSN_tot .eq. 0) return					  if (nSN_tot .eq. 0) return
  								  
  if(myid==1)then						  if(myid==1)then
     write(*,*)'---------------------------------------------	     write(*,*)'---------------------------------------------
     write(*,*)'Number of GMC to explode=',nSN_tot		     write(*,*)'Number of GMC to explode=',nSN_tot
     write(*,*)'---------------------------------------------	     write(*,*)'---------------------------------------------
  endif								  endif

  ! Allocate arrays for the position and the mass of the SN	  ! Allocate arrays for the position and the mass of the SN
  allocate(xSN(1:nSN_tot,1:3),vSN(1:nSN_tot,1:3))		  allocate(xSN(1:nSN_tot,1:3),vSN(1:nSN_tot,1:3))
  allocate(mSN(1:nSN_tot),sSN(1:nSN_tot),ZSN(1:nSN_tot))	  allocate(mSN(1:nSN_tot),sSN(1:nSN_tot),ZSN(1:nSN_tot))
  xSN=0.;vSN=0.;mSN=0.;sSN=0.;ZSN=0.				  xSN=0.;vSN=0.;mSN=0.;sSN=0.;ZSN=0.
  ! Allocate arrays for particles index and parent grid		  ! Allocate arrays for particles index and parent grid
  if(nSN_loc>0)then						  if(nSN_loc>0)then
     allocate(ind_part(1:nSN_loc),ind_grid(1:nSN_loc),ok_free	     allocate(ind_part(1:nSN_loc),ind_grid(1:nSN_loc),ok_free
  endif								  endif

  !------------------------------------------------------	  !------------------------------------------------------
  ! Store position and mass of the GMC into the SN array	  ! Store position and mass of the GMC into the SN array
  !------------------------------------------------------	  !------------------------------------------------------
  if(myid==1)then						  if(myid==1)then
     iSN=0							     iSN=0
  else								  else
     iSN=sum(nSN_icpu(1:myid-1))				     iSN=sum(nSN_icpu(1:myid-1))
  endif								  endif
  ! Loop over levels						  ! Loop over levels
  ip=0								  ip=0
  do icpu=1,ncpu						  do icpu=1,ncpu
     igrid=headl(icpu,levelmin)					     igrid=headl(icpu,levelmin)
     ! Loop over grids						     ! Loop over grids
     do jgrid=1,numbl(icpu,levelmin)				     do jgrid=1,numbl(icpu,levelmin)
        npart1=numbp(igrid)  ! Number of particles in the gri	        npart1=numbp(igrid)  ! Number of particles in the gri
        ! Count old enough star particles that have not explo	        ! Count old enough star particles that have not explo
        if(npart1>0)then					        if(npart1>0)then
           ipart=headp(igrid)					           ipart=headp(igrid)
           ! Loop over particles				           ! Loop over particles
           do jpart=1,npart1					           do jpart=1,npart1
              ! Save next particle   <--- Very important !!!	              ! Save next particle   <--- Very important !!!
              next_part=nextp(ipart)				              next_part=nextp(ipart)
              if(idp(ipart).le.0.and. tp(ipart).lt.(t-t0))the |	              if(idp(ipart).le.0.and. tp(ipart).lt.(current_t
                 iSN=iSN+1					                 iSN=iSN+1
                 xSN(iSN,1)=xp(ipart,1)				                 xSN(iSN,1)=xp(ipart,1)
                 xSN(iSN,2)=xp(ipart,2)				                 xSN(iSN,2)=xp(ipart,2)
                 xSN(iSN,3)=xp(ipart,3)				                 xSN(iSN,3)=xp(ipart,3)
                 vSN(iSN,1)=vp(ipart,1)				                 vSN(iSN,1)=vp(ipart,1)
                 vSN(iSN,2)=vp(ipart,2)				                 vSN(iSN,2)=vp(ipart,2)
                 vSN(iSN,3)=vp(ipart,3)				                 vSN(iSN,3)=vp(ipart,3)
                 mSN(iSN)=mp(ipart)				                 mSN(iSN)=mp(ipart)
                 sSN(iSN)=dble(-idp(ipart))*mstar		                 sSN(iSN)=dble(-idp(ipart))*mstar
                 if(metal)ZSN(iSN)=zp(ipart)			                 if(metal)ZSN(iSN)=zp(ipart)
                 ip=ip+1					                 ip=ip+1
                 ind_grid(ip)=igrid				                 ind_grid(ip)=igrid
                 ind_part(ip)=ipart				                 ind_part(ip)=ipart
              endif						              endif
              ipart=next_part  ! Go to next particle		              ipart=next_part  ! Go to next particle
           end do						           end do
        endif							        endif
        igrid=next(igrid)   ! Go to next grid			        igrid=next(igrid)   ! Go to next grid
     end do							     end do
  end do 							  end do 
  ! End loop over levels					  ! End loop over levels

  ! Remove GMC particle						  ! Remove GMC particle
  IF(nSN_loc>0)then						  IF(nSN_loc>0)then
     ok_free=.true.						     ok_free=.true.
     call remove_list(ind_part,ind_grid,ok_free,nSN_loc)	     call remove_list(ind_part,ind_grid,ok_free,nSN_loc)
     call add_free_cond(ind_part,ok_free,nSN_loc)		     call add_free_cond(ind_part,ok_free,nSN_loc)
     deallocate(ind_part,ind_grid,ok_free)			     deallocate(ind_part,ind_grid,ok_free)
  endif								  endif

#ifndef WITHOUTMPI						#ifndef WITHOUTMPI
  allocate(xSN_all(1:nSN_tot,1:3),vSN_all(1:nSN_tot,1:3),mSN_	  allocate(xSN_all(1:nSN_tot,1:3),vSN_all(1:nSN_tot,1:3),mSN_
  call MPI_ALLREDUCE(xSN,xSN_all,nSN_tot*3,MPI_DOUBLE_PRECISI	  call MPI_ALLREDUCE(xSN,xSN_all,nSN_tot*3,MPI_DOUBLE_PRECISI
  call MPI_ALLREDUCE(vSN,vSN_all,nSN_tot*3,MPI_DOUBLE_PRECISI	  call MPI_ALLREDUCE(vSN,vSN_all,nSN_tot*3,MPI_DOUBLE_PRECISI
  call MPI_ALLREDUCE(mSN,mSN_all,nSN_tot  ,MPI_DOUBLE_PRECISI	  call MPI_ALLREDUCE(mSN,mSN_all,nSN_tot  ,MPI_DOUBLE_PRECISI
  call MPI_ALLREDUCE(sSN,sSN_all,nSN_tot  ,MPI_DOUBLE_PRECISI	  call MPI_ALLREDUCE(sSN,sSN_all,nSN_tot  ,MPI_DOUBLE_PRECISI
  call MPI_ALLREDUCE(ZSN,ZSN_all,nSN_tot  ,MPI_DOUBLE_PRECISI	  call MPI_ALLREDUCE(ZSN,ZSN_all,nSN_tot  ,MPI_DOUBLE_PRECISI
  xSN=xSN_all							  xSN=xSN_all
  vSN=vSN_all							  vSN=vSN_all
  mSN=mSN_all							  mSN=mSN_all
  sSN=sSN_all							  sSN=sSN_all
  ZSN=ZSN_all							  ZSN=ZSN_all
  deallocate(xSN_all,vSN_all,mSN_all,sSN_all,ZSN_all)		  deallocate(xSN_all,vSN_all,mSN_all,sSN_all,ZSN_all)
#endif								#endif

  nSN=nSN_tot							  nSN=nSN_tot
  allocate(m_gas(1:nSN),u_gas(1:nSN,1:3),vol_gas(1:nSN),dq(1:	  allocate(m_gas(1:nSN),u_gas(1:nSN,1:3),vol_gas(1:nSN),dq(1:
  allocate(indSN(1:nSN))					  allocate(indSN(1:nSN))

  ! Compute the grid discretization effects			  ! Compute the grid discretization effects
  call average_SN(xSN,vol_gas,dq,ekBlast,indSN,nSN)		  call average_SN(xSN,vol_gas,dq,ekBlast,indSN,nSN)

  ! Modify hydro quantities to account for a Sedov blast wave	  ! Modify hydro quantities to account for a Sedov blast wave
  call Sedov_blast(xSN,vSN,mSN,sSN,ZSN,indSN,vol_gas,dq,ekBla	  call Sedov_blast(xSN,vSN,mSN,sSN,ZSN,indSN,vol_gas,dq,ekBla

  deallocate(xSN,vSN,mSN,sSN,ZSN,indSN,m_gas,u_gas,vol_gas,dq	  deallocate(xSN,vSN,mSN,sSN,ZSN,indSN,m_gas,u_gas,vol_gas,dq

  ! Update hydro quantities for split cells			  ! Update hydro quantities for split cells
  do ilevel=nlevelmax,levelmin,-1				  do ilevel=nlevelmax,levelmin,-1
     call upload_fine(ilevel)					     call upload_fine(ilevel)
     do ivar=1,nvar						     do ivar=1,nvar
        call make_virtual_fine_dp(uold(1,ivar),ilevel)		        call make_virtual_fine_dp(uold(1,ivar),ilevel)
     enddo							     enddo
  enddo								  enddo

end subroutine kinetic_feedback					end subroutine kinetic_feedback
!############################################################	!############################################################
!############################################################	!############################################################
!############################################################	!############################################################
!############################################################	!############################################################
subroutine average_SN(xSN,vol_gas,dq,ekBlast,ind_blast,nSN)	subroutine average_SN(xSN,vol_gas,dq,ekBlast,ind_blast,nSN)
  use pm_commons						  use pm_commons
  use amr_commons						  use amr_commons
  use hydro_commons						  use hydro_commons
  implicit none							  implicit none
#ifndef WITHOUTMPI						#ifndef WITHOUTMPI
  include 'mpif.h'						  include 'mpif.h'
#endif								#endif
  !----------------------------------------------------------	  !----------------------------------------------------------
  ! This routine average the hydro quantities inside the SN b	  ! This routine average the hydro quantities inside the SN b
  !----------------------------------------------------------	  !----------------------------------------------------------
  integer::ilevel,ncache,nSN,j,iSN,ind,ix,iy,iz,ngrid,iskip	  integer::ilevel,ncache,nSN,j,iSN,ind,ix,iy,iz,ngrid,iskip
  integer::i,nx_loc,igrid,info					  integer::i,nx_loc,igrid,info
  integer,dimension(1:nvector),save::ind_grid,ind_cell		  integer,dimension(1:nvector),save::ind_grid,ind_cell
  real(dp)::x,y,z,dr_SN,d,u,v,w,ek,u2,v2,w2,dr_cell		  real(dp)::x,y,z,dr_SN,d,u,v,w,ek,u2,v2,w2,dr_cell
  real(dp)::scale,dx,dxx,dyy,dzz,dx_min,dx_loc,vol_loc,rmax2,	  real(dp)::scale,dx,dxx,dyy,dzz,dx_min,dx_loc,vol_loc,rmax2,
  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v	  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v
  real(dp),dimension(1:3)::skip_loc				  real(dp),dimension(1:3)::skip_loc
  real(dp),dimension(1:twotondim,1:3)::xc			  real(dp),dimension(1:twotondim,1:3)::xc
  integer ,dimension(1:nSN)::ind_blast				  integer ,dimension(1:nSN)::ind_blast
  real(dp),dimension(1:nSN)::mSN,m_gas,vol_gas,ekBlast		  real(dp),dimension(1:nSN)::mSN,m_gas,vol_gas,ekBlast
  real(dp),dimension(1:nSN,1:3)::xSN,vSN,u_gas,dq,u2Blast	  real(dp),dimension(1:nSN,1:3)::xSN,vSN,u_gas,dq,u2Blast
#ifndef WITHOUTMPI						#ifndef WITHOUTMPI
  real(dp),dimension(1:nSN)::m_gas_all,vol_gas_all,ekBlast_al	  real(dp),dimension(1:nSN)::m_gas_all,vol_gas_all,ekBlast_al
  real(dp),dimension(1:nSN,1:3)::u_gas_all,dq_all,u2Blast_all	  real(dp),dimension(1:nSN,1:3)::u_gas_all,dq_all,u2Blast_all
#endif								#endif
  logical ,dimension(1:nvector),save::ok			  logical ,dimension(1:nvector),save::ok

  if(nSN==0)return						  if(nSN==0)return
  if(verbose)write(*,*)'Entering average_SN'			  if(verbose)write(*,*)'Entering average_SN'

  ! Mesh spacing in that level					  ! Mesh spacing in that level
  nx_loc=(icoarse_max-icoarse_min+1)				  nx_loc=(icoarse_max-icoarse_min+1)
  skip_loc=(/0.0d0,0.0d0,0.0d0/)				  skip_loc=(/0.0d0,0.0d0,0.0d0/)
  skip_loc(1)=dble(icoarse_min)					  skip_loc(1)=dble(icoarse_min)
  skip_loc(2)=dble(jcoarse_min)					  skip_loc(2)=dble(jcoarse_min)
  skip_loc(3)=dble(kcoarse_min)					  skip_loc(3)=dble(kcoarse_min)
  scale=boxlen/dble(nx_loc)					  scale=boxlen/dble(nx_loc)
  dx_min=scale*0.5D0**nlevelmax					  dx_min=scale*0.5D0**nlevelmax

  ! Conversion factor from user units to cgs units		  ! Conversion factor from user units to cgs units
  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T	  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T

  ! Maximum radius of the ejecta				  ! Maximum radius of the ejecta
  rmax=MAX(2.0d0*dx_min*scale_l/aexp,rbubble*3.08d18)		  rmax=MAX(2.0d0*dx_min*scale_l/aexp,rbubble*3.08d18)
  rmax=rmax/scale_l						  rmax=rmax/scale_l
  rmax2=rmax*rmax						  rmax2=rmax*rmax

  ! Initialize the averaged variables				  ! Initialize the averaged variables
  vol_gas=0.0;dq=0.0;u2Blast=0.0;ekBlast=0.0;ind_blast=-1	  vol_gas=0.0;dq=0.0;u2Blast=0.0;ekBlast=0.0;ind_blast=-1

  ! Loop over levels						  ! Loop over levels
  do ilevel=levelmin,nlevelmax					  do ilevel=levelmin,nlevelmax
     ! Computing local volume (important for averaging hydro 	     ! Computing local volume (important for averaging hydro 
     dx=0.5D0**ilevel 						     dx=0.5D0**ilevel 
     dx_loc=dx*scale						     dx_loc=dx*scale
     vol_loc=dx_loc**ndim					     vol_loc=dx_loc**ndim
     ! Cells center position relative to grid center position	     ! Cells center position relative to grid center position
     do ind=1,twotondim  					     do ind=1,twotondim  
        iz=(ind-1)/4						        iz=(ind-1)/4
        iy=(ind-1-4*iz)/2					        iy=(ind-1-4*iz)/2
        ix=(ind-1-2*iy-4*iz)					        ix=(ind-1-2*iy-4*iz)
        xc(ind,1)=(dble(ix)-0.5D0)*dx				        xc(ind,1)=(dble(ix)-0.5D0)*dx
        xc(ind,2)=(dble(iy)-0.5D0)*dx				        xc(ind,2)=(dble(iy)-0.5D0)*dx
        xc(ind,3)=(dble(iz)-0.5D0)*dx				        xc(ind,3)=(dble(iz)-0.5D0)*dx
     end do							     end do

     ! Loop over grids						     ! Loop over grids
     ncache=active(ilevel)%ngrid				     ncache=active(ilevel)%ngrid
     do igrid=1,ncache,nvector					     do igrid=1,ncache,nvector
        ngrid=MIN(nvector,ncache-igrid+1)			        ngrid=MIN(nvector,ncache-igrid+1)
        do i=1,ngrid						        do i=1,ngrid
           ind_grid(i)=active(ilevel)%igrid(igrid+i-1)		           ind_grid(i)=active(ilevel)%igrid(igrid+i-1)
        end do							        end do

        ! Loop over cells					        ! Loop over cells
        do ind=1,twotondim  					        do ind=1,twotondim  
           iskip=ncoarse+(ind-1)*ngridmax			           iskip=ncoarse+(ind-1)*ngridmax
           do i=1,ngrid						           do i=1,ngrid
              ind_cell(i)=iskip+ind_grid(i)			              ind_cell(i)=iskip+ind_grid(i)
           end do						           end do

           ! Flag leaf cells					           ! Flag leaf cells
           do i=1,ngrid						           do i=1,ngrid
              ok(i)=son(ind_cell(i))==0				              ok(i)=son(ind_cell(i))==0
           end do						           end do

           do i=1,ngrid						           do i=1,ngrid
              if(ok(i))then					              if(ok(i))then
                 ! Get gas cell position			                 ! Get gas cell position
                 x=(xg(ind_grid(i),1)+xc(ind,1)-skip_loc(1))*	                 x=(xg(ind_grid(i),1)+xc(ind,1)-skip_loc(1))*
                 y=(xg(ind_grid(i),2)+xc(ind,2)-skip_loc(2))*	                 y=(xg(ind_grid(i),2)+xc(ind,2)-skip_loc(2))*
                 z=(xg(ind_grid(i),3)+xc(ind,3)-skip_loc(3))*	                 z=(xg(ind_grid(i),3)+xc(ind,3)-skip_loc(3))*
                 do iSN=1,nSN					                 do iSN=1,nSN
                    ! Check if the cell lies within the SN ra	                    ! Check if the cell lies within the SN ra
                    dxx=x-xSN(iSN,1)				                    dxx=x-xSN(iSN,1)
                    dyy=y-xSN(iSN,2)				                    dyy=y-xSN(iSN,2)
                    dzz=z-xSN(iSN,3)				                    dzz=z-xSN(iSN,3)
                    dr_SN=dxx**2+dyy**2+dzz**2			                    dr_SN=dxx**2+dyy**2+dzz**2
                    dr_cell=MAX(ABS(dxx),ABS(dyy),ABS(dzz))	                    dr_cell=MAX(ABS(dxx),ABS(dyy),ABS(dzz))
                    if(dr_SN.lt.rmax2)then			                    if(dr_SN.lt.rmax2)then
                       vol_gas(iSN)=vol_gas(iSN)+vol_loc	                       vol_gas(iSN)=vol_gas(iSN)+vol_loc
                       ! Take account for grid effects on the	                       ! Take account for grid effects on the
                       ! normalized linear momentum		                       ! normalized linear momentum
                       u=dxx/rmax				                       u=dxx/rmax
                       v=dyy/rmax				                       v=dyy/rmax
                       w=dzz/rmax				                       w=dzz/rmax
                       ! Add the local normalized linear mome	                       ! Add the local normalized linear mome
                       ! momentum of the blast wave (should b	                       ! momentum of the blast wave (should b
                       dq(iSN,1)=dq(iSN,1)+u*vol_loc		                       dq(iSN,1)=dq(iSN,1)+u*vol_loc
                       dq(iSN,2)=dq(iSN,2)+v*vol_loc		                       dq(iSN,2)=dq(iSN,2)+v*vol_loc
                       dq(iSN,3)=dq(iSN,3)+w*vol_loc		                       dq(iSN,3)=dq(iSN,3)+w*vol_loc
                       u2Blast(iSN,1)=u2Blast(iSN,1)+u*u*vol_	                       u2Blast(iSN,1)=u2Blast(iSN,1)+u*u*vol_
                       u2Blast(iSN,2)=u2Blast(iSN,2)+v*v*vol_	                       u2Blast(iSN,2)=u2Blast(iSN,2)+v*v*vol_
                       u2Blast(iSN,3)=u2Blast(iSN,3)+w*w*vol_	                       u2Blast(iSN,3)=u2Blast(iSN,3)+w*w*vol_
                    endif					                    endif
                    if(dr_cell.le.dx_loc/2.0)then		                    if(dr_cell.le.dx_loc/2.0)then
                       ind_blast(iSN)=ind_cell(i)		                       ind_blast(iSN)=ind_cell(i)
                       ekBlast  (iSN)=vol_loc			                       ekBlast  (iSN)=vol_loc
                    endif					                    endif
                 end do						                 end do
              endif						              endif
           end do						           end do
           							           
        end do							        end do
        ! End loop over cells					        ! End loop over cells
     end do							     end do
     ! End loop over grids					     ! End loop over grids
  end do							  end do
  ! End loop over levels					  ! End loop over levels

#ifndef WITHOUTMPI						#ifndef WITHOUTMPI
  call MPI_ALLREDUCE(vol_gas,vol_gas_all,nSN  ,MPI_DOUBLE_PRE	  call MPI_ALLREDUCE(vol_gas,vol_gas_all,nSN  ,MPI_DOUBLE_PRE
  call MPI_ALLREDUCE(dq     ,dq_all     ,nSN*3,MPI_DOUBLE_PRE	  call MPI_ALLREDUCE(dq     ,dq_all     ,nSN*3,MPI_DOUBLE_PRE
  call MPI_ALLREDUCE(u2Blast,u2Blast_all,nSN*3,MPI_DOUBLE_PRE	  call MPI_ALLREDUCE(u2Blast,u2Blast_all,nSN*3,MPI_DOUBLE_PRE
  call MPI_ALLREDUCE(ekBlast,ekBlast_all,nSN  ,MPI_DOUBLE_PRE	  call MPI_ALLREDUCE(ekBlast,ekBlast_all,nSN  ,MPI_DOUBLE_PRE
  vol_gas=vol_gas_all						  vol_gas=vol_gas_all
  dq     =dq_all						  dq     =dq_all
  u2Blast=u2Blast_all						  u2Blast=u2Blast_all
  ekBlast=ekBlast_all						  ekBlast=ekBlast_all
#endif								#endif
  do iSN=1,nSN							  do iSN=1,nSN
     if(vol_gas(iSN)>0d0)then					     if(vol_gas(iSN)>0d0)then
        dq(iSN,1)=dq(iSN,1)/vol_gas(iSN)			        dq(iSN,1)=dq(iSN,1)/vol_gas(iSN)
        dq(iSN,2)=dq(iSN,2)/vol_gas(iSN)			        dq(iSN,2)=dq(iSN,2)/vol_gas(iSN)
        dq(iSN,3)=dq(iSN,3)/vol_gas(iSN)			        dq(iSN,3)=dq(iSN,3)/vol_gas(iSN)
        u2Blast(iSN,1)=u2Blast(iSN,1)/vol_gas(iSN)		        u2Blast(iSN,1)=u2Blast(iSN,1)/vol_gas(iSN)
        u2Blast(iSN,2)=u2Blast(iSN,2)/vol_gas(iSN)		        u2Blast(iSN,2)=u2Blast(iSN,2)/vol_gas(iSN)
        u2Blast(iSN,3)=u2Blast(iSN,3)/vol_gas(iSN)		        u2Blast(iSN,3)=u2Blast(iSN,3)/vol_gas(iSN)
        u2=u2Blast(iSN,1)-dq(iSN,1)**2				        u2=u2Blast(iSN,1)-dq(iSN,1)**2
        v2=u2Blast(iSN,2)-dq(iSN,2)**2				        v2=u2Blast(iSN,2)-dq(iSN,2)**2
        w2=u2Blast(iSN,3)-dq(iSN,3)**2				        w2=u2Blast(iSN,3)-dq(iSN,3)**2
        ekBlast(iSN)=max(0.5d0*(u2+v2+w2),0.0d0)		        ekBlast(iSN)=max(0.5d0*(u2+v2+w2),0.0d0)
     endif							     endif
  end do							  end do

  if(verbose)write(*,*)'Exiting average_SN'			  if(verbose)write(*,*)'Exiting average_SN'

end subroutine average_SN					end subroutine average_SN
!############################################################	!############################################################
!############################################################	!############################################################
!############################################################	!############################################################
!############################################################	!############################################################
subroutine Sedov_blast(xSN,vSN,mSN,sSN,ZSN,indSN,vol_gas,dq,e	subroutine Sedov_blast(xSN,vSN,mSN,sSN,ZSN,indSN,vol_gas,dq,e
  use pm_commons						  use pm_commons
  use amr_commons						  use amr_commons
  use hydro_commons						  use hydro_commons
  implicit none							  implicit none
#ifndef WITHOUTMPI						#ifndef WITHOUTMPI
  include 'mpif.h'						  include 'mpif.h'
#endif								#endif
  !----------------------------------------------------------	  !----------------------------------------------------------
  ! This routine merges SN using the FOF algorithm.		  ! This routine merges SN using the FOF algorithm.
  !----------------------------------------------------------	  !----------------------------------------------------------
  integer::ilevel,j,iSN,nSN,ind,ix,iy,iz,ngrid,iskip		  integer::ilevel,j,iSN,nSN,ind,ix,iy,iz,ngrid,iskip
  integer::i,nx_loc,igrid,info,ncache				  integer::i,nx_loc,igrid,info,ncache
  integer,dimension(1:nvector),save::ind_grid,ind_cell		  integer,dimension(1:nvector),save::ind_grid,ind_cell
  real(dp)::x,y,z,dx,dxx,dyy,dzz,dr_SN,d,u,v,w,ek,u_r,ESN	  real(dp)::x,y,z,dx,dxx,dyy,dzz,dr_SN,d,u,v,w,ek,u_r,ESN
  real(dp)::scale,dx_min,dx_loc,vol_loc,rmax2,rmax		  real(dp)::scale,dx_min,dx_loc,vol_loc,rmax2,rmax
  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v	  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v
  real(dp),dimension(1:3)::skip_loc				  real(dp),dimension(1:3)::skip_loc
  real(dp),dimension(1:twotondim,1:3)::xc			  real(dp),dimension(1:twotondim,1:3)::xc
  real(dp),dimension(1:nSN)::mSN,sSN,ZSN,m_gas,p_gas,d_gas,d_	  real(dp),dimension(1:nSN)::mSN,sSN,ZSN,m_gas,p_gas,d_gas,d_
  real(dp),dimension(1:nSN,1:3)::xSN,vSN,u_gas,dq		  real(dp),dimension(1:nSN,1:3)::xSN,vSN,u_gas,dq
  integer ,dimension(1:nSN)::indSN				  integer ,dimension(1:nSN)::indSN
  logical ,dimension(1:nvector),save::ok			  logical ,dimension(1:nvector),save::ok

  if(nSN==0)return						  if(nSN==0)return
  if(verbose)write(*,*)'Entering Sedov_blast'			  if(verbose)write(*,*)'Entering Sedov_blast'

  ! Mesh spacing in that level					  ! Mesh spacing in that level
  nx_loc=(icoarse_max-icoarse_min+1)				  nx_loc=(icoarse_max-icoarse_min+1)
  skip_loc=(/0.0d0,0.0d0,0.0d0/)				  skip_loc=(/0.0d0,0.0d0,0.0d0/)
  skip_loc(1)=dble(icoarse_min)					  skip_loc(1)=dble(icoarse_min)
  skip_loc(2)=dble(jcoarse_min)					  skip_loc(2)=dble(jcoarse_min)
  skip_loc(3)=dble(kcoarse_min)					  skip_loc(3)=dble(kcoarse_min)
  scale=boxlen/dble(nx_loc)					  scale=boxlen/dble(nx_loc)
  dx_min=scale*0.5D0**nlevelmax					  dx_min=scale*0.5D0**nlevelmax

  ! Conversion factor from user units to cgs units		  ! Conversion factor from user units to cgs units
  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T	  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T

  ! Maximum radius of the ejecta				  ! Maximum radius of the ejecta
  rmax=MAX(2.0d0*dx_min*scale_l/aexp,rbubble*3.08d18)		  rmax=MAX(2.0d0*dx_min*scale_l/aexp,rbubble*3.08d18)
  rmax=rmax/scale_l						  rmax=rmax/scale_l
  rmax2=rmax*rmax						  rmax2=rmax*rmax
  								  
  ! Supernova specific energy from cgs to code units		  ! Supernova specific energy from cgs to code units
  ESN=(1d51/(10d0*2d33))/scale_v**2				  ESN=(1d51/(10d0*2d33))/scale_v**2

  do iSN=1,nSN							  do iSN=1,nSN
     if(vol_gas(iSN)>0d0)then					     if(vol_gas(iSN)>0d0)then
        d_gas(iSN)=mSN(iSN)/vol_gas(iSN)			        d_gas(iSN)=mSN(iSN)/vol_gas(iSN)
        if(metal)d_metal(iSN)=ZSN(iSN)*mSN(iSN)/vol_gas(iSN)	        if(metal)d_metal(iSN)=ZSN(iSN)*mSN(iSN)/vol_gas(iSN)
        if(ekBlast(iSN)==0d0)then				        if(ekBlast(iSN)==0d0)then
           p_gas(iSN)=eta_sn*sSN(iSN)*ESN/vol_gas(iSN)		           p_gas(iSN)=eta_sn*sSN(iSN)*ESN/vol_gas(iSN)
           uSedov(iSN)=0d0					           uSedov(iSN)=0d0
        else							        else
           p_gas(iSN)=(1d0-f_ek)*eta_sn*sSN(iSN)*ESN/vol_gas(	           p_gas(iSN)=(1d0-f_ek)*eta_sn*sSN(iSN)*ESN/vol_gas(
           uSedov(iSN)=sqrt(f_ek*eta_sn*sSN(iSN)*ESN/mSN(iSN)	           uSedov(iSN)=sqrt(f_ek*eta_sn*sSN(iSN)*ESN/mSN(iSN)
        endif							        endif
     else							     else
        d_gas(iSN)=mSN(iSN)/ekBlast(iSN)			        d_gas(iSN)=mSN(iSN)/ekBlast(iSN)
        p_gas(iSN)=eta_sn*sSN(iSN)*ESN/ekBlast(iSN)		        p_gas(iSN)=eta_sn*sSN(iSN)*ESN/ekBlast(iSN)
        if(metal)d_metal(iSN)=ZSN(iSN)*mSN(iSN)/ekBlast(iSN)	        if(metal)d_metal(iSN)=ZSN(iSN)*mSN(iSN)/ekBlast(iSN)
     endif							     endif
  end do							  end do

  ! Loop over levels						  ! Loop over levels
  do ilevel=levelmin,nlevelmax					  do ilevel=levelmin,nlevelmax
     ! Computing local volume (important for averaging hydro 	     ! Computing local volume (important for averaging hydro 
     dx=0.5D0**ilevel 						     dx=0.5D0**ilevel 
     dx_loc=dx*scale						     dx_loc=dx*scale
     vol_loc=dx_loc**ndim					     vol_loc=dx_loc**ndim
     ! Cells center position relative to grid center position	     ! Cells center position relative to grid center position
     do ind=1,twotondim  					     do ind=1,twotondim  
        iz=(ind-1)/4						        iz=(ind-1)/4
        iy=(ind-1-4*iz)/2					        iy=(ind-1-4*iz)/2
        ix=(ind-1-2*iy-4*iz)					        ix=(ind-1-2*iy-4*iz)
        xc(ind,1)=(dble(ix)-0.5D0)*dx				        xc(ind,1)=(dble(ix)-0.5D0)*dx
        xc(ind,2)=(dble(iy)-0.5D0)*dx				        xc(ind,2)=(dble(iy)-0.5D0)*dx
        xc(ind,3)=(dble(iz)-0.5D0)*dx				        xc(ind,3)=(dble(iz)-0.5D0)*dx
     end do							     end do

     ! Loop over grids						     ! Loop over grids
     ncache=active(ilevel)%ngrid				     ncache=active(ilevel)%ngrid
     do igrid=1,ncache,nvector					     do igrid=1,ncache,nvector
        ngrid=MIN(nvector,ncache-igrid+1)			        ngrid=MIN(nvector,ncache-igrid+1)
        do i=1,ngrid						        do i=1,ngrid
           ind_grid(i)=active(ilevel)%igrid(igrid+i-1)		           ind_grid(i)=active(ilevel)%igrid(igrid+i-1)
        end do							        end do

        ! Loop over cells					        ! Loop over cells
        do ind=1,twotondim  					        do ind=1,twotondim  
           iskip=ncoarse+(ind-1)*ngridmax			           iskip=ncoarse+(ind-1)*ngridmax
           do i=1,ngrid						           do i=1,ngrid
              ind_cell(i)=iskip+ind_grid(i)			              ind_cell(i)=iskip+ind_grid(i)
           end do						           end do

           ! Flag leaf cells					           ! Flag leaf cells
           do i=1,ngrid						           do i=1,ngrid
              ok(i)=son(ind_cell(i))==0				              ok(i)=son(ind_cell(i))==0
           end do						           end do

           do i=1,ngrid						           do i=1,ngrid
              if(ok(i))then					              if(ok(i))then
                 ! Get gas cell position			                 ! Get gas cell position
                 x=(xg(ind_grid(i),1)+xc(ind,1)-skip_loc(1))*	                 x=(xg(ind_grid(i),1)+xc(ind,1)-skip_loc(1))*
                 y=(xg(ind_grid(i),2)+xc(ind,2)-skip_loc(2))*	                 y=(xg(ind_grid(i),2)+xc(ind,2)-skip_loc(2))*
                 z=(xg(ind_grid(i),3)+xc(ind,3)-skip_loc(3))*	                 z=(xg(ind_grid(i),3)+xc(ind,3)-skip_loc(3))*
                 do iSN=1,nSN					                 do iSN=1,nSN
                    ! Check if the cell lies within the SN ra	                    ! Check if the cell lies within the SN ra
                    dxx=x-xSN(iSN,1)				                    dxx=x-xSN(iSN,1)
                    dyy=y-xSN(iSN,2)				                    dyy=y-xSN(iSN,2)
                    dzz=z-xSN(iSN,3)				                    dzz=z-xSN(iSN,3)
                    dr_SN=dxx**2+dyy**2+dzz**2			                    dr_SN=dxx**2+dyy**2+dzz**2
                    if(dr_SN.lt.rmax2)then			                    if(dr_SN.lt.rmax2)then
                       ! Compute the mass density in the cell	                       ! Compute the mass density in the cell
                       uold(ind_cell(i),1)=uold(ind_cell(i),1	                       uold(ind_cell(i),1)=uold(ind_cell(i),1
                       ! Compute the metal density in the cel	                       ! Compute the metal density in the cel
                       if(metal)uold(ind_cell(i),imetal)=uold	                       if(metal)uold(ind_cell(i),imetal)=uold
                       ! Velocity at a given dr_SN linearly i	                       ! Velocity at a given dr_SN linearly i
                       u=uSedov(iSN)*(dxx/rmax-dq(iSN,1))+vSN	                       u=uSedov(iSN)*(dxx/rmax-dq(iSN,1))+vSN
                       v=uSedov(iSN)*(dyy/rmax-dq(iSN,2))+vSN	                       v=uSedov(iSN)*(dyy/rmax-dq(iSN,2))+vSN
                       w=uSedov(iSN)*(dzz/rmax-dq(iSN,3))+vSN	                       w=uSedov(iSN)*(dzz/rmax-dq(iSN,3))+vSN
                       ! Add each momentum component of the b	                       ! Add each momentum component of the b
                       uold(ind_cell(i),2)=uold(ind_cell(i),2	                       uold(ind_cell(i),2)=uold(ind_cell(i),2
                       uold(ind_cell(i),3)=uold(ind_cell(i),3	                       uold(ind_cell(i),3)=uold(ind_cell(i),3
                       uold(ind_cell(i),4)=uold(ind_cell(i),4	                       uold(ind_cell(i),4)=uold(ind_cell(i),4
                       ! Finally update the total energy of t	                       ! Finally update the total energy of t
                       uold(ind_cell(i),5)=uold(ind_cell(i),5	                       uold(ind_cell(i),5)=uold(ind_cell(i),5
                    endif					                    endif
                 end do						                 end do
              endif						              endif
           end do						           end do
           							           
        end do							        end do
        ! End loop over cells					        ! End loop over cells
     end do							     end do
     ! End loop over grids					     ! End loop over grids
  end do							  end do
  ! End loop over levels					  ! End loop over levels

  do iSN=1,nSN							  do iSN=1,nSN
     if(vol_gas(iSN)==0d0)then					     if(vol_gas(iSN)==0d0)then
        u=vSN(iSN,1)						        u=vSN(iSN,1)
        v=vSN(iSN,2)						        v=vSN(iSN,2)
        w=vSN(iSN,3)						        w=vSN(iSN,3)
        if(indSN(iSN)>0)then					        if(indSN(iSN)>0)then
           uold(indSN(iSN),1)=uold(indSN(iSN),1)+d_gas(iSN)	           uold(indSN(iSN),1)=uold(indSN(iSN),1)+d_gas(iSN)
           uold(indSN(iSN),2)=uold(indSN(iSN),2)+d_gas(iSN)*u	           uold(indSN(iSN),2)=uold(indSN(iSN),2)+d_gas(iSN)*u
           uold(indSN(iSN),3)=uold(indSN(iSN),3)+d_gas(iSN)*v	           uold(indSN(iSN),3)=uold(indSN(iSN),3)+d_gas(iSN)*v
           uold(indSN(iSN),4)=uold(indSN(iSN),4)+d_gas(iSN)*w	           uold(indSN(iSN),4)=uold(indSN(iSN),4)+d_gas(iSN)*w
           uold(indSN(iSN),5)=uold(indSN(iSN),5)+d_gas(iSN)*0	           uold(indSN(iSN),5)=uold(indSN(iSN),5)+d_gas(iSN)*0
           if(metal)uold(indSN(iSN),imetal)=uold(indSN(iSN),i	           if(metal)uold(indSN(iSN),imetal)=uold(indSN(iSN),i
        endif							        endif
     endif							     endif
  end do							  end do

  if(verbose)write(*,*)'Exiting Sedov_blast'			  if(verbose)write(*,*)'Exiting Sedov_blast'

end subroutine Sedov_blast					end subroutine Sedov_blast
!###########################################################	!###########################################################
!###########################################################	!###########################################################
!###########################################################	!###########################################################
!###########################################################	!###########################################################
